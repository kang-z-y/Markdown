# 面向对象三大特征

## 封装

- **对象代表什么吗，就得封装对应的数据，并提供数据对应的行为**

## 继承

- Java中提供一个关键字***extends***，用这个关键字，可以让一个类和另一个类建立起继承关系。

  `public class Student extends Person {}`

- Student称为**子类（派生类）**，Person称为**父类（基类或超类）**。

### 使用继承的好处

- 可以把多个子类中重复的代码抽取到父类中，提高代码的复用性。
- 子类可以在父类的基础上，增加其他的功能，使子类更强大。

### 什么时候用继承？

- **当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承来优化代码**

### 继承的特点

- **java只支持单继承，不支持多继承，但支持多层继承。**

  *单继承：一个子类只能继承一个父类*

  *不支持多继承：子类不能同时继承多个父类*

  *多层继承：包括直接继承与间接继承*

- **Java中所有的类都直接或间接继承于Object类。**
- **子类只能访问父类中的非私有成员**

---

#### 继承中：成员变量的访问特点

- **就近原则：谁离我近，我就用谁**
- ***this*与*super*（this调用：就近原则；super调用：直接找父类）**

#### 继承中：成员方法的访问特点

- **直接调用满足就近原则：谁离我近，我就用谁**
- ***super*调用，直接访问父类**

### 子类可以继承父类中的哪些内容？

|          |              |               |
| :------: | :----------- | :------------ |
| 构造方法 | 非私有：不能 | private：不能 |
| 成员变量 | 非私有：能   | private：能   |
| 成员方法 | 虚方法表：能 | 否则：不能    |

- **只有父类中的虚方法（不被private、static、final关键字修饰）才能被子类继承**

### 方法的重写

​ 当父类的方法不能满足子类现在的需求是，需要进行方法重写

---

#### 书写格式

​ 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。

#### @Override重写注解

1. @Override是放在重写后的方法上，校验子类方法重写时语法是否正确。
2. 加上注解后，如果有红色波浪线，表示语法错误。
3. **建议重写方法都加@Override注解，代码安全、优雅！**

#### 方法重写的本质

​ 如果发生了重写，子类的虚方法表中对应的父类方法会被覆盖

#### 方法重写注意事项和要求

1. 重写方法的名称、形参列表必须与父类中的一致。
2. 子类重写父类方法时，访问权限子类必须大于等于父类。（暂时了解：空着不写<protected<public）
3. 子类重写父类方法时，返回值类型子类必须小于等于父类。
4. **建议：重写的方法尽量和父类保持一致。**
5. 只有会被添加到虚方法表中的方法才能被重写。

#### 继承中：构造方法的访问特点

- 父类的构造方法不会被子类继承。
- 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。

##### 为什么？

- 子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。
- **子类初始化之前，一定要掉用父类构造方法先完成父类数据空间的初始化。**

##### 怎么调用父类的构造方法的？

- 子类构造方法的第一行语句默认都是：**super()，不写也存在，且必须在第一行。**
- **如果想调用父类的有参构造，必须手动写super进行调用。**

## 多态

### 什么是多态？

​ 同类型的对象，表现出的不同形态。

#### 多态的表现形式

​ **父类类型 对象名称 = 子类对象;**

#### 多态的前提

- **有继承/实现关系**
- **有父类引用指向子类对象**    `Fu f = new Zi ( );`
- **有方法的重写**

#### 多态的好处

- 使用父类型作为参数，可以接受所有子类对象，体现多态的扩展性与便利。

#### 多态调用成员的特点

- 变量调用：编译看左边，运行也看左边。
- 方法调用：编译看左边，运行看右边。

#### 多态的优势

- 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。

  ```java
  Person p = new Student();
  p.work(); //业务逻辑发生改变时，后续代码无需修改
  ```

- 定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。

#### 多态的弊端

- 不能调用子类特有的功能

##### 解决方案

- 变回子类类型就可以了

- **细节：转换的时候不能瞎转，如果转成其他类的类型，就会报错**

- 可以使用**`instanceof`**关键字对对该对象要转换的类型进行判断

  ```java
  if(a instanceof Dog) {
      Dog d = (Dog) a;
      d.lookHome();
  } else if(a instanceof Cat) {
      Cat c = (Cat) a;
      c.catchMouse();
  }
  ```

  ```java
  //JDK14的新特性
  if(a instanceof Dog d) {
      d.lookHome();
  } else if(a instanceof Cat c) {
      c.catchMouse();
  }
  ```

#### 扩展：引用数据类型的类型转换

- 包括：**自动类型转换、强制类型转换**

##### 强制类型转换能解决生么问题？

- 可以转换成真正的子类类型，从而调用子类的独有功能
- 转换类型与真实对象类型不一致时会报错
- 转换的时候用**`instanceof`**关键字进行判断
